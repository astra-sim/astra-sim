/******************************************************************************
This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.
*******************************************************************************/

#include "common/CallbackTracker.hh"
#include <cassert>

using namespace AstraSimAnalytical;

CallbackTracker::CallbackTracker() noexcept {
  // initialize tracker
  tracker = {};
}

std::optional<CallbackTrackerEntry*> CallbackTracker::search_entry(
    const int tag,
    const int src,
    const int dest,
    const ChunkSize chunk_size,
    const int chunk_id) noexcept {
  assert(tag >= 0);
  assert(src >= 0);
  assert(dest >= 0);
  assert(chunk_size > 0);
  assert(chunk_id >= 0);

  // create key and search entry
  const auto key = std::make_tuple(tag, src, dest, chunk_size, chunk_id);
  const auto entry = tracker.find(key);

  // no entry exists
  if (entry == tracker.end()) {
    return std::nullopt;
  }

  // return pointer to entry
  return &(entry->second);
}

CallbackTrackerEntry* CallbackTracker::create_new_entry(
    const int tag,
    const int src,
    const int dest,
    const ChunkSize chunk_size,
    const int chunk_id) noexcept {
  assert(tag >= 0);
  assert(src >= 0);
  assert(dest >= 0);
  assert(chunk_size > 0);
  assert(chunk_id >= 0);

  // create key
  const auto key = std::make_tuple(tag, src, dest, chunk_size, chunk_id);

  // create new emtpy entry
  const auto entry = tracker.emplace(key, CallbackTrackerEntry()).first;

  // return pointer to entry
  return &(entry->second);
}

void CallbackTracker::pop_entry(
    const int tag,
    const int src,
    const int dest,
    const ChunkSize chunk_size,
    const int chunk_id) noexcept {
  assert(tag >= 0);
  assert(src >= 0);
  assert(dest >= 0);
  assert(chunk_size > 0);
  assert(chunk_id >= 0);

  // create key
  const auto key = std::make_tuple(tag, src, dest, chunk_size, chunk_id);

  // find entry
  const auto entry = tracker.find(key);
  assert(entry != tracker.end()); // entry must exist

  // erase entry from the tracker
  tracker.erase(entry);
}
